# RISCV Assembly Language (Stack Frames and Function Calls)

## Introduction
The goals of this lab are:

    * Practise writing A64 assembly language
    * Learn to use the gdb debugger
    * Understand stack frames and function calls

ARM Linux will be used for this lab. Refer to [Learn the architecture - A64 Instruction Set Architecture Guide](https://developer.arm.com/documentation/102374/0101) for information ob the A64 instruction set architecture.

## Part 1 - printdec (20%)
The following C program, printdec, prints the decimal value of 10 random numbers.

```C
#include <stdio.h>
#include <stdlib.h>

void
printdec(int n)
{
    while (n > 0)
    {
        int c = n % 10;
        putchar(c + '0');
        n /= 10;
    }
    putchar('\n');
}

int
main()
{
    srand(0);
    for (int i = 0; i < 10; i++)
    {
        int r = rand();

        printdec(r);
    }
    return 0;
}
```

The supplied copy of the program is split into 2 files, ```main.c``` and ```printdec.c```.
It can be compiled the commands below. Note how ```printdec.c``` is first compiled to ```printdec.s``` and then assembled to ```printdec.o```.

```bash
% make
gcc    -c -o main.o main.c
gcc -S  printdec.c
as -o printdec.o printdec.s
gcc -o printdec main.o printdec.o
```

It is executed as follows:
```bash
% ./printdec
039239025
19652982
514487228
278954098
167235541
1483272312
0163400401
7330553461
89526386
14433466
```

## Lab Questions


### Part 1 - Annotated printdec.s (30%)
You can see the assembly language generated by the C compiler as follows.
```bash
% cat printdec.s
	.section	__TEXT,__text,regular,pure_instructions
	.build_version macos, 14, 0	sdk_version 14, 4
	.globl	_printdec                       ; -- Begin function printdec
	.p2align	2
_printdec:                              ; @printdec
	.cfi_startproc
; %bb.0:
	sub	sp, sp, #32
	.cfi_def_cfa_offset 32
	stp	x29, x30, [sp, #16]             ; 16-byte Folded Spill
	add	x29, sp, #16
	.cfi_def_cfa w29, 16
	.cfi_offset w30, -8
	.cfi_offset w29, -16
	stur	w0, [x29, #-4]
	b	LBB0_1
LBB0_1:                                 ; =>This Inner Loop Header: Depth=1
	ldur	w8, [x29, #-4]
	subs	w8, w8, #0
	cset	w8, le
	tbnz	w8, #0, LBB0_3
	b	LBB0_2
LBB0_2:                                 ;   in Loop: Header=BB0_1 Depth=1
	ldur	w8, [x29, #-4]
	mov	w10, #10
	str	w10, [sp, #4]                   ; 4-byte Folded Spill
	sdiv	w9, w8, w10
	mul	w9, w9, w10
	subs	w8, w8, w9
	str	w8, [sp, #8]
	ldr	w8, [sp, #8]
	add	w0, w8, #48
	bl	_putchar
	ldr	w9, [sp, #4]                    ; 4-byte Folded Reload
	ldur	w8, [x29, #-4]
	sdiv	w8, w8, w9
	stur	w8, [x29, #-4]
	b	LBB0_1
LBB0_3:
	mov	w0, #10
	bl	_putchar
	ldp	x29, x30, [sp, #16]             ; 16-byte Folded Reload
	add	sp, sp, #32
	ret
	.cfi_endproc
                                        ; -- End function
.subsections_via_symbols
```
Using gdb, put a breakpoint just before the call to printdec (```bl _printdec```) and display the value of the ```r``` variable. 
Single step the assembly language using gdb with the ```nexti``` command
and understand the operation of the program. Show the sequence of commands that you need in gdb to step ```_printdec``` and display the register values.

Create an annotated version of ```printdec.s``` with lots of comments that explain how it works. Put this in your lab book and make sure you explain the correspondence with each line of C.

### Part 2 - Assembly Language version of printdec (40%)
Note that _printdec uses the stack frame for temporary variables. Rewrite in A64 assembly language using registers.
When doing this exercise, it is unlikely your program will work first time so use the single step and register display facilities in gdb to debug your work. Note that you solution must be hand-written assembly language - we can tell the difference!

### Part 3 - Assembly Language version of printdec (30%)
From Part 2, you should have noticed that printdec() prints the string in the reverse order. Modify your assembly language program to fix this bug. Do this by buffering the data inside printdec() and then print out the buffer in reverse.


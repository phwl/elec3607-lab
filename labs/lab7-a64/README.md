# RISCV Assembly Language (Stack Frames and Function Calls)

## Introduction
The goals of this lab are:

    * Practise writing A64 assembly language
    * Learn to use the gdb debugger
    * Understand stack frames and function calls

ARM Linux will be used for this lab. Refer to [Learn the architecture - A64 Instruction Set Architecture Guide](https://developer.arm.com/documentation/102374/0101) for information ob the A64 instruction set architecture.

## Part 1 - Write a program that print
The following C program prints 10 random numbers.

```C
#include <stdio.h>
#include <stdlib.h>

void
printdec(int n)
{
    while (n > 0)
    {
        int c = n % 10;
        putchar(c + '0');
        n /= 10;
    }
    putchar('\n');
}

int
main()
{
    srand(0);
    for (int i = 0; i < 10; i++)
    {
        int r = rand();

        printdec(r);
    }
    return 0;
}
```

It can be compiled and executed using the commands below.

```bash
% make
cc    -c -o printdec.o printdec.c
cc   printdec.o   -o printdec
% ./printdec
039239025
19652982
514487228
278954098
167235541
1483272312
0163400401
7330553461
89526386
14433466
```

You can see the assembly language generated by the C compiler with the following commands.
```bash
(base) phwl@AHJ7LDH57JP lab7-a64 % gcc -S printdec.c
(base) phwl@AHJ7LDH57JP lab7-a64 % more printdec.s
        .section        __TEXT,__text,regular,pure_instructions
        .build_version macos, 14, 0     sdk_version 14, 4
        .globl  _printdec                       ; -- Begin function printdec
        .p2align        2
_printdec:                              ; @printdec
        .cfi_startproc
; %bb.0:
        sub     sp, sp, #32
        .cfi_def_cfa_offset 32
        stp     x29, x30, [sp, #16]             ; 16-byte Folded Spill
        add     x29, sp, #16
        .cfi_def_cfa w29, 16
        .cfi_offset w30, -8
        .cfi_offset w29, -16
        stur    w0, [x29, #-4]
        b       LBB0_1
LBB0_1:                                 ; =>This Inner Loop Header: Depth=1
        ldur    w8, [x29, #-4]
        subs    w8, w8, #0
        cset    w8, le
        tbnz    w8, #0, LBB0_3
        b       LBB0_2
LBB0_2:                                 ;   in Loop: Header=BB0_1 Depth=1
        ldur    w8, [x29, #-4]
        mov     w10, #10
        str     w10, [sp, #4]                   ; 4-byte Folded Spill
        sdiv    w9, w8, w10
        mul     w9, w9, w10
        subs    w8, w8, w9
        str     w8, [sp, #8]
        ldr     w8, [sp, #8]
        add     w0, w8, #48
        bl      _putchar
        ldr     w9, [sp, #4]                    ; 4-byte Folded Reload
        ldur    w8, [x29, #-4]
        sdiv    w8, w8, w9
        stur    w8, [x29, #-4]
        b       LBB0_1
LBB0_3:
        mov     w0, #10
        bl      _putchar
        ldp     x29, x30, [sp, #16]             ; 16-byte Folded Reload
        add     sp, sp, #32
        ret
        .cfi_endproc
                                        ; -- End function
        .globl  _main                           ; -- Begin function main
        .p2align        2
_main:                                  ; @main
        .cfi_startproc
; %bb.0:
        sub     sp, sp, #48
        .cfi_def_cfa_offset 48
        stp     x29, x30, [sp, #32]             ; 16-byte Folded Spill
        add     x29, sp, #32
        .cfi_def_cfa w29, 16
        .cfi_offset w30, -8
        .cfi_offset w29, -16
        mov     w0, #0
        stur    wzr, [x29, #-4]
        bl      _srand
        stur    wzr, [x29, #-8]
        b       LBB1_1
LBB1_1:                                 ; =>This Inner Loop Header: Depth=1
        ldur    w8, [x29, #-8]
        subs    w8, w8, #10
        cset    w8, ge
        tbnz    w8, #0, LBB1_4
        b       LBB1_2
LBB1_2:                                 ;   in Loop: Header=BB1_1 Depth=1
        bl      _rand
        stur    w0, [x29, #-12]
        ldur    w9, [x29, #-12]
                                        ; implicit-def: $x8
        mov     x8, x9
        mov     x9, sp
        str     x8, [x9]
        adrp    x0, l_.str@PAGE
        add     x0, x0, l_.str@PAGEOFF
        bl      _printf
        ldur    w0, [x29, #-12]
        bl      _printdec
        b       LBB1_3
LBB1_3:                                 ;   in Loop: Header=BB1_1 Depth=1
        ldur    w8, [x29, #-8]
        add     w8, w8, #1
        stur    w8, [x29, #-8]
        b       LBB1_1
LBB1_4:
        mov     w0, #0
        ldp     x29, x30, [sp, #32]             ; 16-byte Folded Reload
        add     sp, sp, #48
        ret
        .cfi_endproc
                                        ; -- End function
        .section        __TEXT,__cstring,cstring_literals
l_.str:                                 ; @.str
        .asciz  "%d: "

.subsections_via_symbols
```

Lab Questions

When doing these exercises, it is unlikely your programs will work first time. Use the single step and register display facilities in spike to debug your work. Your solutions must be hand-written assembly language - we can tell the different to a C compiled output!

    (10%) The startup sequence runs a lot of initialisation code before it reaches the main() function. Use the "nm fact" command and identify the address of main(). Use spike to excecute until you reach main() and single step until it calls printf().
    (10%) Modify the fact.s program so that it prints “Hello world\n” 10 times. Your answer must use a loop.
    (30%) The following recursive subroutine is a direct implementation of the formula:

fact(0) = 1
fact(n) = n * fact(n-1)         (n > 0).

If you are unclear about C calling conventions, the principle is clearly described in the textbook under "Procedure Call Convention'.

fact:
        addi sp, sp, -8     # adjust stack for 2 items
        sw   ra, 4(sp)      # save return address
        sw   a0, 0(sp)      # save argument - this is a local variable allocated on the stack
        li   t0, 2          # put a 2 into t0
        bgeu a0, t0, L1     # if n >= 2 take jump
        li   a0, 1          # otherwise, result is 1
        addi sp, sp, 8      #   pop 2 items from stack
        jr   ra             #   and return
L1:     addi a0, a0, -1     # else decrement n
        jal  fact           # recursive call to get fact(n-1)
        lw   t0, 0(sp)      # restore original n
        mul  a0, t0, a0     # multiply to get result n * fact(n-1)
        lw   ra, 4(sp)      # restore return address
        addi sp, sp, 8      # pop 2 items from stack
        jr   ra             # and return

Write a program using this subroutine so that it computes and prints out fact(n) for n=0 … 9. You must use a loop and the output should be:

fact(0)=1
fact(1)=1
fact(2)=2
fact(3)=6
fact(4)=24
fact(5)=120
fact(6)=720
fact(7)=5040
fact(8)=40320
fact(9)=362880
fact(10)=3628800

Make sure you understand the way the stack works so that each time the fact() function is called from itself, its a0 and ra are pushed to different sp addresses so they do not overwrite themselves.

    (50%) Modify the factorial program to compute the Fibonacci numbers for n=0 … 19. Your solution should be a recursive one where:

fib(0) = 0
fib(1) = 1
fib(n) = fib(n-1) + fib(n-2)    (n > 1)

Hint: in a manner similar to the recursive fact() function, save intermediate results on the stack as anything in temporary registers will be overwritten when a recursive call is made.

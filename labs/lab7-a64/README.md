# RISCV Assembly Language (Stack Frames and Function Calls)

## Introduction
The goals of this lab are:

    * Practise writing A64 assembly language
    * Learn to use the gdb debugger
    * Understand stack frames and function calls

ARM Linux will be used for this lab. Refer to [Learn the architecture - A64 Instruction Set Architecture Guide](https://developer.arm.com/documentation/102374/0101) for information ob the A64 instruction set architecture.

## Part 1 - Write a program that print
The following C program prints 10 random numbers.

```C
#include <stdio.h>
#include <stdlib.h>

void
printdec(int n)
{
    while (n > 0)
    {
        int c = n % 10;
        putchar(c + '0');
        n /= 10;
    }
    putchar('\n');
}

int
main()
{
    srand(0);
    for (int i = 0; i < 10; i++)
    {
        int r = rand();

        printdec(r);
    }
    return 0;
}
```

It can be compiled and executed using the commands below.

```bash
% make
cc    -c -o printdec.o printdec.c
cc   printdec.o   -o printdec
% ./printdec
039239025
19652982
514487228
278954098
167235541
1483272312
0163400401
7330553461
89526386
14433466
```

You can see the assembly language generated by the C compiler with the following commands.
```bash
% gcc -S -O3 printdec.c
% cat printdec.s
	.section	__TEXT,__text,regular,pure_instructions
	.build_version macos, 14, 0	sdk_version 14, 4
	.globl	_printdec                       ; -- Begin function printdec
	.p2align	2
_printdec:                              ; @printdec
	.cfi_startproc
; %bb.0:
	stp	x22, x21, [sp, #-48]!           ; 16-byte Folded Spill
	.cfi_def_cfa_offset 48
	stp	x20, x19, [sp, #16]             ; 16-byte Folded Spill
	stp	x29, x30, [sp, #32]             ; 16-byte Folded Spill
	add	x29, sp, #32
	.cfi_def_cfa w29, 16
	.cfi_offset w30, -8
	.cfi_offset w29, -16
	.cfi_offset w19, -24
	.cfi_offset w20, -32
	.cfi_offset w21, -40
	.cfi_offset w22, -48
	cmp	w0, #1
	b.lt	LBB0_3
; %bb.1:
	mov	x19, x0
	mov	w20, #52429
	movk	w20, #52428, lsl #16
	mov	w21, #10
LBB0_2:                                 ; =>This Inner Loop Header: Depth=1
	umull	x8, w19, w20
	lsr	x22, x8, #35
	msub	w8, w22, w21, w19
	orr	w0, w8, #0x30
	bl	_putchar
	cmp	w19, #9
	mov	x19, x22
	b.hi	LBB0_2
LBB0_3:
	mov	w0, #10
	ldp	x29, x30, [sp, #32]             ; 16-byte Folded Reload
	ldp	x20, x19, [sp, #16]             ; 16-byte Folded Reload
	ldp	x22, x21, [sp], #48             ; 16-byte Folded Reload
	b	_putchar
	.cfi_endproc
                                        ; -- End function
	.globl	_main                           ; -- Begin function main
	.p2align	2
_main:                                  ; @main
	.cfi_startproc
; %bb.0:
	sub	sp, sp, #64
	.cfi_def_cfa_offset 64
	stp	x22, x21, [sp, #16]             ; 16-byte Folded Spill
	stp	x20, x19, [sp, #32]             ; 16-byte Folded Spill
	stp	x29, x30, [sp, #48]             ; 16-byte Folded Spill
	add	x29, sp, #48
	.cfi_def_cfa w29, 16
	.cfi_offset w30, -8
	.cfi_offset w29, -16
	.cfi_offset w19, -24
	.cfi_offset w20, -32
	.cfi_offset w21, -40
	.cfi_offset w22, -48
	mov	w0, #0
	bl	_srand
	bl	_rand
	mov	x19, x0
	str	x0, [sp]
Lloh0:
	adrp	x0, l_.str@PAGE
Lloh1:
	add	x0, x0, l_.str@PAGEOFF
	bl	_printf
	cmp	w19, #1
	b.lt	LBB1_3
; %bb.1:
	mov	w20, #52429
	movk	w20, #52428, lsl #16
	mov	w21, #10
LBB1_2:                                 ; =>This Inner Loop Header: Depth=1
	umull	x8, w19, w20
	lsr	x22, x8, #35
	msub	w8, w22, w21, w19
	orr	w0, w8, #0x30
	bl	_putchar
	cmp	w19, #9
	mov	x19, x22
	b.hi	LBB1_2
LBB1_3:
	mov	w20, #10
	mov	w0, #10
	bl	_putchar
	bl	_rand
	mov	x19, x0
	str	x0, [sp]
Lloh2:
	adrp	x0, l_.str@PAGE
Lloh3:
	add	x0, x0, l_.str@PAGEOFF
	bl	_printf
	cmp	w19, #1
	b.lt	LBB1_6
; %bb.4:
	mov	w21, #52429
	movk	w21, #52428, lsl #16
LBB1_5:                                 ; =>This Inner Loop Header: Depth=1
	umull	x8, w19, w21
	lsr	x22, x8, #35
	msub	w8, w22, w20, w19
	orr	w0, w8, #0x30
	bl	_putchar
	cmp	w19, #9
	mov	x19, x22
	b.hi	LBB1_5
LBB1_6:
	mov	w20, #10
	mov	w0, #10
	bl	_putchar
	bl	_rand
	mov	x19, x0
	str	x0, [sp]
Lloh4:
	adrp	x0, l_.str@PAGE
Lloh5:
	add	x0, x0, l_.str@PAGEOFF
	bl	_printf
	cmp	w19, #1
	b.lt	LBB1_9
; %bb.7:
	mov	w21, #52429
	movk	w21, #52428, lsl #16
LBB1_8:                                 ; =>This Inner Loop Header: Depth=1
	umull	x8, w19, w21
	lsr	x22, x8, #35
	msub	w8, w22, w20, w19
	orr	w0, w8, #0x30
	bl	_putchar
	cmp	w19, #9
	mov	x19, x22
	b.hi	LBB1_8
LBB1_9:
	mov	w20, #10
	mov	w0, #10
	bl	_putchar
	bl	_rand
	mov	x19, x0
	str	x0, [sp]
Lloh6:
	adrp	x0, l_.str@PAGE
Lloh7:
	add	x0, x0, l_.str@PAGEOFF
	bl	_printf
	cmp	w19, #1
	b.lt	LBB1_12
; %bb.10:
	mov	w21, #52429
	movk	w21, #52428, lsl #16
LBB1_11:                                ; =>This Inner Loop Header: Depth=1
	umull	x8, w19, w21
	lsr	x22, x8, #35
	msub	w8, w22, w20, w19
	orr	w0, w8, #0x30
	bl	_putchar
	cmp	w19, #9
	mov	x19, x22
	b.hi	LBB1_11
LBB1_12:
	mov	w20, #10
	mov	w0, #10
	bl	_putchar
	bl	_rand
	mov	x19, x0
	str	x0, [sp]
Lloh8:
	adrp	x0, l_.str@PAGE
Lloh9:
	add	x0, x0, l_.str@PAGEOFF
	bl	_printf
	cmp	w19, #1
	b.lt	LBB1_15
; %bb.13:
	mov	w21, #52429
	movk	w21, #52428, lsl #16
LBB1_14:                                ; =>This Inner Loop Header: Depth=1
	umull	x8, w19, w21
	lsr	x22, x8, #35
	msub	w8, w22, w20, w19
	orr	w0, w8, #0x30
	bl	_putchar
	cmp	w19, #9
	mov	x19, x22
	b.hi	LBB1_14
LBB1_15:
	mov	w20, #10
	mov	w0, #10
	bl	_putchar
	bl	_rand
	mov	x19, x0
	str	x0, [sp]
Lloh10:
	adrp	x0, l_.str@PAGE
Lloh11:
	add	x0, x0, l_.str@PAGEOFF
	bl	_printf
	cmp	w19, #1
	b.lt	LBB1_18
; %bb.16:
	mov	w21, #52429
	movk	w21, #52428, lsl #16
LBB1_17:                                ; =>This Inner Loop Header: Depth=1
	umull	x8, w19, w21
	lsr	x22, x8, #35
	msub	w8, w22, w20, w19
	orr	w0, w8, #0x30
	bl	_putchar
	cmp	w19, #9
	mov	x19, x22
	b.hi	LBB1_17
LBB1_18:
	mov	w20, #10
	mov	w0, #10
	bl	_putchar
	bl	_rand
	mov	x19, x0
	str	x0, [sp]
Lloh12:
	adrp	x0, l_.str@PAGE
Lloh13:
	add	x0, x0, l_.str@PAGEOFF
	bl	_printf
	cmp	w19, #1
	b.lt	LBB1_21
; %bb.19:
	mov	w21, #52429
	movk	w21, #52428, lsl #16
LBB1_20:                                ; =>This Inner Loop Header: Depth=1
	umull	x8, w19, w21
	lsr	x22, x8, #35
	msub	w8, w22, w20, w19
	orr	w0, w8, #0x30
	bl	_putchar
	cmp	w19, #9
	mov	x19, x22
	b.hi	LBB1_20
LBB1_21:
	mov	w20, #10
	mov	w0, #10
	bl	_putchar
	bl	_rand
	mov	x19, x0
	str	x0, [sp]
Lloh14:
	adrp	x0, l_.str@PAGE
Lloh15:
	add	x0, x0, l_.str@PAGEOFF
	bl	_printf
	cmp	w19, #1
	b.lt	LBB1_24
; %bb.22:
	mov	w21, #52429
	movk	w21, #52428, lsl #16
LBB1_23:                                ; =>This Inner Loop Header: Depth=1
	umull	x8, w19, w21
	lsr	x22, x8, #35
	msub	w8, w22, w20, w19
	orr	w0, w8, #0x30
	bl	_putchar
	cmp	w19, #9
	mov	x19, x22
	b.hi	LBB1_23
LBB1_24:
	mov	w20, #10
	mov	w0, #10
	bl	_putchar
	bl	_rand
	mov	x19, x0
	str	x0, [sp]
Lloh16:
	adrp	x0, l_.str@PAGE
Lloh17:
	add	x0, x0, l_.str@PAGEOFF
	bl	_printf
	cmp	w19, #1
	b.lt	LBB1_27
; %bb.25:
	mov	w21, #52429
	movk	w21, #52428, lsl #16
LBB1_26:                                ; =>This Inner Loop Header: Depth=1
	umull	x8, w19, w21
	lsr	x22, x8, #35
	msub	w8, w22, w20, w19
	orr	w0, w8, #0x30
	bl	_putchar
	cmp	w19, #9
	mov	x19, x22
	b.hi	LBB1_26
LBB1_27:
	mov	w20, #10
	mov	w0, #10
	bl	_putchar
	bl	_rand
	mov	x19, x0
	str	x0, [sp]
Lloh18:
	adrp	x0, l_.str@PAGE
Lloh19:
	add	x0, x0, l_.str@PAGEOFF
	bl	_printf
	cmp	w19, #1
	b.lt	LBB1_30
; %bb.28:
	mov	w21, #52429
	movk	w21, #52428, lsl #16
LBB1_29:                                ; =>This Inner Loop Header: Depth=1
	umull	x8, w19, w21
	lsr	x22, x8, #35
	msub	w8, w22, w20, w19
	orr	w0, w8, #0x30
	bl	_putchar
	cmp	w19, #9
	mov	x19, x22
	b.hi	LBB1_29
LBB1_30:
	mov	w0, #10
	bl	_putchar
	mov	w0, #0
	ldp	x29, x30, [sp, #48]             ; 16-byte Folded Reload
	ldp	x20, x19, [sp, #32]             ; 16-byte Folded Reload
	ldp	x22, x21, [sp, #16]             ; 16-byte Folded Reload
	add	sp, sp, #64
	ret
	.loh AdrpAdd	Lloh0, Lloh1
	.loh AdrpAdd	Lloh2, Lloh3
	.loh AdrpAdd	Lloh4, Lloh5
	.loh AdrpAdd	Lloh6, Lloh7
	.loh AdrpAdd	Lloh8, Lloh9
	.loh AdrpAdd	Lloh10, Lloh11
	.loh AdrpAdd	Lloh12, Lloh13
	.loh AdrpAdd	Lloh14, Lloh15
	.loh AdrpAdd	Lloh16, Lloh17
	.loh AdrpAdd	Lloh18, Lloh19
	.cfi_endproc
                                        ; -- End function
	.section	__TEXT,__cstring,cstring_literals
l_.str:                                 ; @.str
	.asciz	"%d: "

.subsections_via_symbols
```

Lab Questions

When doing these exercises, it is unlikely your programs will work first time. Use the single step and register display facilities in spike to debug your work. Your solutions must be hand-written assembly language - we can tell the different to a C compiled output!

    (10%) The startup sequence runs a lot of initialisation code before it reaches the main() function. Use the "nm fact" command and identify the address of main(). Use spike to excecute until you reach main() and single step until it calls printf().
    (10%) Modify the fact.s program so that it prints “Hello world\n” 10 times. Your answer must use a loop.
    (30%) The following recursive subroutine is a direct implementation of the formula:

fact(0) = 1
fact(n) = n * fact(n-1)         (n > 0).

If you are unclear about C calling conventions, the principle is clearly described in the textbook under "Procedure Call Convention'.

fact:
        addi sp, sp, -8     # adjust stack for 2 items
        sw   ra, 4(sp)      # save return address
        sw   a0, 0(sp)      # save argument - this is a local variable allocated on the stack
        li   t0, 2          # put a 2 into t0
        bgeu a0, t0, L1     # if n >= 2 take jump
        li   a0, 1          # otherwise, result is 1
        addi sp, sp, 8      #   pop 2 items from stack
        jr   ra             #   and return
L1:     addi a0, a0, -1     # else decrement n
        jal  fact           # recursive call to get fact(n-1)
        lw   t0, 0(sp)      # restore original n
        mul  a0, t0, a0     # multiply to get result n * fact(n-1)
        lw   ra, 4(sp)      # restore return address
        addi sp, sp, 8      # pop 2 items from stack
        jr   ra             # and return

Write a program using this subroutine so that it computes and prints out fact(n) for n=0 … 9. You must use a loop and the output should be:

fact(0)=1
fact(1)=1
fact(2)=2
fact(3)=6
fact(4)=24
fact(5)=120
fact(6)=720
fact(7)=5040
fact(8)=40320
fact(9)=362880
fact(10)=3628800

Make sure you understand the way the stack works so that each time the fact() function is called from itself, its a0 and ra are pushed to different sp addresses so they do not overwrite themselves.

    (50%) Modify the factorial program to compute the Fibonacci numbers for n=0 … 19. Your solution should be a recursive one where:

fib(0) = 0
fib(1) = 1
fib(n) = fib(n-1) + fib(n-2)    (n > 1)

Hint: in a manner similar to the recursive fact() function, save intermediate results on the stack as anything in temporary registers will be overwritten when a recursive call is made.

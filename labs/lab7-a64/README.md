# RISCV Assembly Language (Stack Frames and Function Calls)

## Introduction
The goals of this lab are:

    * Practise writing A64 assembly language
    * Learn to use the gdb debugger
    * Understand stack frames and function calls

ARM Linux will be used for this lab. Refer to [Learn the architecture - A64 Instruction Set Architecture Guide](https://developer.arm.com/documentation/102374/0101) for information ob the A64 instruction set architecture. 

The following C program, printdec, prints the decimal value of 10 random numbers.

```C
#include <stdio.h>
#include <stdlib.h>

void
printdec(int n)
{
    while (n > 0)
    {
        int c = n % 10;
        putchar(c + '0');
        n /= 10;
    }
    putchar('\n');
}

int
main()
{
    srand(0);
    for (int i = 0; i < 10; i++)
    {
        int r = rand();

        printdec(r);
    }
    return 0;
}
```

The supplied copy of the program is split into 2 files, ```main.c``` and ```printdec.c```.
It can be compiled the commands below. Note how ```printdec.c``` is first compiled to ```printdec.s``` and then assembled to ```printdec.o```.

```bash
$ make
gcc    -c -o main.o main.c
gcc -S  printdec.c
as -o printdec.o printdec.s
gcc -o printdec main.o printdec.o
```

It is executed as follows:
```bash
$ make
$ ./printdec 
3839824081
688039648
7772961861
5196364171
3977477591
533832424
683588917
2940679461
946615695
1241469811
```

## Lab Questions

In your
answers, make sure that your assembly language code is clearly commented.

### Part 1 - Annotated printdec.s (30%)
You can see the assembly language generated by the C compiler as follows.
```as
% cat printdec.s
	.arch armv6
	.eabi_attribute 28, 1
	.eabi_attribute 20, 1
	.eabi_attribute 21, 1
	.eabi_attribute 23, 3
	.eabi_attribute 24, 1
	.eabi_attribute 25, 1
	.eabi_attribute 26, 2
	.eabi_attribute 30, 6
	.eabi_attribute 34, 1
	.eabi_attribute 18, 4
	.file	"printdec.c"
	.text
	.align	2
	.global	printdec
	.arch armv6
	.syntax unified
	.arm
	.fpu vfp
	.type	printdec, %function
printdec:
	@ args = 0, pretend = 0, frame = 16
	@ frame_needed = 1, uses_anonymous_args = 0
	push	{fp, lr}
	add	fp, sp, #4
	sub	sp, sp, #16
	str	r0, [fp, #-16]
	b	.L2
.L3:
	ldr	r2, [fp, #-16]
	ldr	r3, .L4
	smull	r1, r3, r3, r2
	asr	r1, r3, #2
	asr	r3, r2, #31
	sub	r1, r1, r3
	mov	r3, r1
	lsl	r3, r3, #2
	add	r3, r3, r1
	lsl	r3, r3, #1
	sub	r3, r2, r3
	str	r3, [fp, #-8]
	ldr	r3, [fp, #-8]
	add	r3, r3, #48
	mov	r0, r3
	bl	putchar
	ldr	r3, [fp, #-16]
	ldr	r2, .L4
	smull	r1, r2, r2, r3
	asr	r2, r2, #2
	asr	r3, r3, #31
	sub	r3, r2, r3
	str	r3, [fp, #-16]
.L2:
	ldr	r3, [fp, #-16]
	cmp	r3, #0
	bgt	.L3
	mov	r0, #10
	bl	putchar
	nop
	sub	sp, fp, #4
	@ sp needed
	pop	{fp, pc}
.L5:
	.align	2
.L4:
	.word	1717986919
	.size	printdec, .-printdec
	.ident	"GCC: (Raspbian 8.3.0-6+rpi1) 8.3.0"
	.section	.note.GNU-stack,"",%progbits
```
Using gdb, put a breakpoint just before the call to printdec (```bl _printdec```) and display the value of the ```r``` variable. 
Single step the assembly language using gdb with the ```nexti``` command
and understand the operation of the program. Show the sequence of commands that you need in gdb to step ```_printdec``` and display the register values.

Create an annotated version of ```printdec.s```. Put this in your lab book and make sure you explain the correspondence with each line of C.

### Part 2 - Assembly Language version of printdec (40%)
When doing this exercise, it is unlikely your program will work first time so use the single step and register display facilities in gdb to debug your work. Note that you solution must be hand-written assembly language - we can tell the difference!

Note that _printdec uses the frame pointer for temporary variables. Rewrite in A64 assembly language using registers.

### Part 3 - Assembly Language version of printdec (30%)
From Part 2, you should have noticed that printdec() prints the string in the reverse order. Modify your assembly language program to fix this bug. Do this by buffering the data inside printdec() and then printing out the buffer in reverse.  

